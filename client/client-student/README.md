# Digital Pathsala Project 2 : Frontend (NextJS)
somechanges
For Frontend we will be using NextJS

## Table Contents

- [Installation & Routing Simple]()

<br>
<br>

## Session Installation & Basic Routing

### 1. Installation

```bash
# Installation Command
```

### 2. Basic Routing

Folder Structure

```bash
src/
└── app
    ├── about
    │   └── page.tsx # aboutPage -> children
    ├── favicon.ico
    ├── globals.css
    ├── layout.tsx # Render Page -> parent
    └── page.tsx   # Index Page  -> children
```

#### _src/app/layout.tsx_

```tsx
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

//  For SEO : Search Engine Optimization
export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        {children}
      </body>
    </html>
  );
}
```

- Note : We rarely touch or modify this code this accepts childrens:pages.

#### _src/app/page.tsx_

```tsx
export default function Home() {
  return <div>Home Page</div>;
}
```

#### _src/app/about/page.tsx_

```tsx
const page = () => {
  return <div>About page</div>;
};
export default page;
```

<br>
 
### QnA:
#### 1. Why we are importing  children function components in the layout.tsx & so on ?
- NextJS which build on the top of ReactJS it imports the functional component file on the basis of folder/file structure.
- _layout.tsx_ accepts the _page.tsx_ all files automaically. for better clarifiction :
- _src/app/layout.tsx_ = `main.tsx` -> Parent 
- _src/app/page.tsx_   = `homePage.tsx` -> route : '/'
- _src/app/page.tsx_   = `homePage.tsx` -> route :about/ 
- So, we don't need to impport files, but we do need to set all fileName as page.tsx & export as default. doing all so handles `router features`

#### `Client Componet` & `Server Component` in _NextJS_?

- `Client Component` : The components which renders only for Client where previously ReactJS only makes `C.Component` only but we can use hooks and DOM

```tsx
"use client";
import React, { useState, useEffect } from "react";
const page = () => {
  const [counter, setCounter] = useState<number>(0);
  useEffect(() => {}, []);
  return <div>console.lof("Hellow world")</div>;
};
```

- `Server Component` : The components which renders only for Server i.e `NextJS` by deafult makes `S.Compoent` for : SEO, browser level features but we cannot use hooks & DOM.

#### Others Loading ...

<br>

### Dynamic Routing : Simple

Folder Structure

```bash
person/
└── [id] # folder name wrapped [id]
    └── page.tsx # fileName
```

#### _person/[id]/page.tsx_

```tsx
import React from "react";
const page = () => {
  return <div>Person</div>;
};
export default page;
```

<br>
<br>

## NextJS Slow File System(turbo fixed)
Some low-pc might perfom NextJS project websites renderingshow due to `turbo` compiler. So, we can make rendering little bit faster throghout some configuration. By the way `turbo` is on the development and that more like to be issue.

#### `Package.json`
```json
  "scripts": {
    "dev": "NEXT_PRIVATE_DEV_SERVER_PROTOCOL=webpack next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
``` 
#### `Package.json`
```json
  "scripts": {
    "dev": "NEXT_PRIVATE_DEV_SERVER_PROTOCOL=webpack next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
``` 

### `next.config.json`

```ts
// next.config.ts
const nextConfig = {
  // No experimental.turbo
  reactStrictMode: true, // optional, for safety
  swcMinify: true, // optional, for performance
};
export default nextConfig;
```
<br>
<br>

## Session : Why we use _State Management_ ? & Types of State Management
1. _API Calls_ Maintable for long term
2. To exchange data between different pages/components

### Types of Statement
1. `Prop Drilling` (Before Standard State Management). 
Process Data : _Parent -> ChildA -> ChildA1 -> ChildA1a -> ChildA1a1_ so on for single data transfering.

2. `Context API` : Central Storage for state managment for children which is wrapped by `XYZ Component` for others it will be not possible. so yeah it's pretty decent for managing, states like togglings : boolean (theme, hide/show) etc. key-points : `createContext()` & `useContext()`

3. `React-Redux & Toolkit` : A better standard package for managing state. It's like a store which provides props all over the components. it's kinda boiler plated but it's goood for heavy or many states to manage.
- Keypoints : `Store`, `createSlice` , `reducer`, `actions`, `payload`, `useSelector`, `useDispatch` plus in `TS` `AppDispatch` & `AppDispatch` 

4. Others : `Zustand`, `Redux`

